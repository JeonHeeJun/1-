{"version":3,"file":"index.spec.js","sourceRoot":"","sources":["../src/index.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { inspect } from \"util\";\nimport sql, { empty, join, raw, Sql } from \"./index\";\n\ndescribe(\"sql template tag\", () => {\n  it(\"should generate sql\", () => {\n    const query = sql`SELECT * FROM books`;\n\n    expect(query.sql).toEqual(\"SELECT * FROM books\");\n    expect(query.text).toEqual(\"SELECT * FROM books\");\n    expect(query.values).toEqual([]);\n  });\n\n  it(\"should store values\", () => {\n    const name = \"Blake\";\n    const query = sql`SELECT * FROM books WHERE author = ${name}`;\n\n    expect(query.sql).toEqual(\"SELECT * FROM books WHERE author = ?\");\n    expect(query.text).toEqual(\"SELECT * FROM books WHERE author = $1\");\n    expect(query.values).toEqual([name]);\n  });\n\n  it(\"should build sql with child sql statements\", () => {\n    const subquery = sql`SELECT id FROM authors WHERE name = ${\"Blake\"}`;\n    const query = sql`SELECT * FROM books WHERE author_id IN (${subquery})`;\n\n    expect(query.text).toEqual(\n      \"SELECT * FROM books WHERE author_id IN (SELECT id FROM authors WHERE name = $1)\"\n    );\n    expect(query.values).toEqual([\"Blake\"]);\n  });\n\n  it(\"should not cache values for mysql compatibility\", () => {\n    const ids = [1, 2, 3];\n    const query = sql`SELECT * FROM books WHERE id IN (${join(\n      ids\n    )}) OR author_id IN (${join(ids)})`;\n\n    expect(query.sql).toEqual(\n      \"SELECT * FROM books WHERE id IN (?,?,?) OR author_id IN (?,?,?)\"\n    );\n    expect(query.text).toEqual(\n      \"SELECT * FROM books WHERE id IN ($1,$2,$3) OR author_id IN ($4,$5,$6)\"\n    );\n    expect(query.values).toEqual([1, 2, 3, 1, 2, 3]);\n  });\n\n  it('should provide \"empty\" helper', () => {\n    const query = sql`SELECT * FROM books ${empty}`;\n\n    expect(query.sql).toEqual(\"SELECT * FROM books \");\n    expect(query.text).toEqual(\"SELECT * FROM books \");\n    expect(query.values).toEqual([]);\n  });\n\n  it(\"should throw in constructor with no strings\", () => {\n    expect(() => new Sql([], [])).toThrowError(\"Expected at least 1 string\");\n  });\n\n  it(\"should throw when values is less than expected\", () => {\n    expect(() => new Sql([\"\", \"\"], [])).toThrowError(\n      \"Expected 2 strings to have 1 values\"\n    );\n  });\n\n  it(\"should inspect sql instance\", () => {\n    expect(inspect(sql`SELECT * FROM test`)).toContain(`'SELECT * FROM test'`);\n  });\n\n  it(\"should have enumerable keys\", () => {\n    const query = sql`SELECT COUNT(1)`;\n    const keys = [];\n\n    for (const key in query) keys.push(key);\n\n    expect(keys).toEqual([\"values\", \"strings\", \"text\", \"sql\"]);\n  });\n\n  it(\"should handle escaped back ticks\", () => {\n    const query = sql`UPDATE user SET \\`name\\` = 'Taylor'`;\n\n    expect(query.text).toEqual(\"UPDATE user SET `name` = 'Taylor'\");\n  });\n\n  describe(\"join\", () => {\n    it(\"should join list\", () => {\n      const query = join([1, 2, 3]);\n\n      expect(query.text).toEqual(\"$1,$2,$3\");\n      expect(query.values).toEqual([1, 2, 3]);\n    });\n\n    it(\"should error joining an empty list\", () => {\n      expect(() => join([])).toThrowError(TypeError);\n    });\n  });\n\n  describe(\"raw\", () => {\n    it(\"should accept any string\", () => {\n      const value = Math.random().toString();\n      const query = raw(value);\n\n      expect(query.sql).toEqual(value);\n      expect(query.values).toEqual([]);\n    });\n  });\n});\n"]}