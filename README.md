# wisesaying-recommand-and-share-app
인생글귀 BACK END
[제작기간] : 2021.3. ~ 2021.12 

[제작인원] : 2명(BE : 1, FE: 1)

[서비스기간] : 2021.4 ~ 2022.04.30(서버 유지 비용때문에 내렸습니다 ㅠㅠ)

[역할] : BE, ML

기존에 존재하던 명언 관련 어플에서 사용자가 공통적으로 불만을 갖는 사항들이 있었습니다.

 해당 문제점들을 보완하고자 새로운 어플을 만들었습니다.

- **관심 없는 명언이 추천되는 문제** : 명언의 태그,  딥러닝 기반 엠베딩 벡터간의 거리를 이용해 사용자가 관심있을 법한 다른 명언을 추천하도록 했습니다.
- **명언의 수가 제한되었던 문제** : 기존 어플은 개발자가 구축한 명언 밖에 볼 수 없었습니다. 사용자가 찾은 명언을 공유하고,  자신만의 명언을 작성할 수 있는 시스템을 만들었습니다.
- **명언 찾기가 어려웠던 문제**  :  명언을 저자, 태그, 내용 등으로 관리해 더 영향력 있는 명언을 쉽게  찾을 수 있는 탐색 시스템을 개발했습니다.

[기술스택] 

```jsx
{
		"platform" :[android] //구글 플레이스토어에 등록했습니다.
    "language": [ javascript, Python ] ,
    "framework": [ nodejs, PyTorch, Flask, GraphQL, Apollo, prisma, postgresql ],
		"cloud" : [ AWS EC2 ubuntu, RDS]
}
```

Notion, github을 이용해  팀원과 협업을 했습니다.

### 기본적인 앱의 기능

로그인 및 명언 탐색, 작성, 명언 좋아요 누르기, 계정 생성, 프로필 변경 등 

- GraphQL,, ApolloServer를 이용해 앱의 기능을 Query, Mutation 단위로 관리
- AWS의 EC2, RDBS를 이용. github를 이용해 로컬에서 개발한 코드를 서버로 옮김
- prisma를 이용한 DB설계 및 간단한 기능 구현
ex) 계정생성, 프로필 변경, 명언 업로드
- postgresql SQL문을 활용한 복잡한 기능 구현
ex) 좋아요 개수가 많은 순서대로 명언 검색, DB초기화시 데이터 bulk loading

### 추천 스케쥴 시스템

추천 스케쥴 : 사용자가 **정한 시간마다 하루에 한번씩  등록한 기기에 푸쉬 알림 형태**로 명언을 추천합니다. 

- **nodejs의 node-schedule 객체**를 이용해 정해진 시간마다 추천 로직 수행. **전역객체** 형태로 로그인한 모든 사용자들의 추천 스케쥴 관리
- **Expo-server-sdk 모듈을 이용한 푸쉬 알림:**
- 여러 발생할 수 있는 **예외 사항** 고려
ex) 서버를 재시작 하는경우 : 로그인상태였던 유저들을 파악해 재시작 할때 추천 스케쥴 다시 생성.
ex) 다른 기기에서 로그인 하는 경우 : 로그인과 동시에 해당 기기의 주소가 담긴 토큰을 등록
ex) 사용자가 앱을 지운 경우 : 해당 사용자의 스케쥴을 서버에서 제외

### 명언 추천 알고리즘

더 넓고 다양한 명언을 추천하기 위해 태그기반, 딥러닝기반의 알고리즘을 개발하고 혼합해 사용했습니다.

- **태그 기반 알고리즘** : **휴리스틱**한 방법. 사용자와 **관련된 태그**들을 뽑고, 태그에 속한 명언 중  **영향력**있는 명언을 추천. 
알고리즘)
1) 사용자가 관심있는 태그들을 조사.(작성한 글의 태그 등) 태그마다 **가중치**를 매김
2) 가중치에 따라 랜덤하게 태그를 뽑음.
3) 2에서 뽑은 태그에 속한 명언들중 **영향력**(좋아요 수가 많음)에 따라 가중치를 두어 최종 추천 명언 선택
- **딥러닝 기반 알고리즘** : 명언마다 **엠베딩 벡터**를 계산. 사용자가 좋아요 누른 명언(편의상 A)을 하나 골라 해당 명언과 **유클리디안 거리**가 가까운 명언을 추천. 
이슈)
1) **BERT(klue/roberta-large)모델**을 이용해 각 명언을 **1024차원 엠베딩 벡터**로 변환.
2) 1024차원의 벡터를 미리 학습된 **AutoEncoder(AE)**를 통해 **128차원**으로 압축:
**계산시간**을 ****줄이고 벡터 간 **유클리디안 거리**에 더욱 의미를 부여하기 위해 압축.
3) 128차원 벡터를 **cube 타입**으로 DB에저장.  cube타입에 **gist 인덱스**를 부여해 유클라디언 거리에 대한 **nearst-search연산** 최적화시킴.

![“철학자가 이야기한 적이 있는 것보다 더 터무니 없는 것은 없다”와 유클리디언 거리가 가까운 상위 20개의 명언들](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0d2fef2a-9676-4028-a9c0-254adc79adc4/Untitled.png)

“철학자가 이야기한 적이 있는 것보다 더 터무니 없는 것은 없다”와 유클리디언 거리가 가까운 상위 20개의 명언들

- **Flask 서버 개설** : 새로운 명언이 추가된다면 BERT → AE를 거쳐 128차원의 엠베딩 벡터를 계산해야함. 
딥러닝 모델은 python으로 구현했기 때문에 추가적으로 **Flask 서버** 개설. 
**nodejs서버의 axious 모듈**과 소통.
- **현재 GAN을 이용한 새로운 추천 모델을 개발중입니다.**
